<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Static Access to Request-Specific Data</title>
  <meta name="author" content="Joel Martinez" />
  <meta name="nlweb:ai-access" content="allow" />
  <link rel="icon" type="image/svg+xml" href="/design/images/codecube-logo-web.svg" />
  <link rel="alternate" type="application/rss+xml" title="Static Access to Request-Specific Data" href="//codecube.net/feed/" />
  <link rel="nlweb-manifest" href="/nlweb.json" />
	<link rel="stylesheet" type="text/css" href="/design/style2.css" />
      <meta name="title" content="Static Access to Request-Specific Data" />
      <meta name="description" content="I wrote a post over on the nGenSoft Blog talking about how to gain Static Access to Request-Specific Data:&#xA;As we have all come to learn in the last decade plus of web development, web applications ..." />
      <link rel="canonical" href="http://codecube.net/2009/11/static-access-to-request-specific-data/" />
      <meta name="twitter:card" content="summary" />
      <meta name="twitter:site" content="@joelmartinez" />
      <meta name="twitter:creator" content="@joelmartinez" />
      <meta name="twitter:title" content="Static Access to Request-Specific Data" />
      <meta name="twitter:description" content="I wrote a post over on the nGenSoft Blog talking about how to gain Static Access to Request-Specific Data:&#xA;As we have all come to learn in the last decade plus of web development, web applications ..." />
      <meta property="og:type" content="article" />
      <meta property="og:title" content="Static Access to Request-Specific Data" />
      <meta property="og:description" content="I wrote a post over on the nGenSoft Blog talking about how to gain Static Access to Request-Specific Data:&#xA;As we have all come to learn in the last decade plus of web development, web applications ..." />
  
  <script src="/script/tone.js"></script>
  <script src="/script/app.gen.js"></script>
</head>
<body>
  <header>
    <div class="branding">
      <a href="/" style="text-decoration: none; display: flex; align-items: center; gap: 1rem;">
        <img
          src="/design/images/codecube-logo-web.svg"
          alt="CodeCube Ventures logo"
          height="48"
          id="site-logo"
        />
        <div class="site-title">
          <span class="title-main">CODECUBE</span>
          <span class="title-sub">VENTURES</span>
        </div>
      </a>
    </div>
    <nav>
      <ul class="nav-list">
        <li><a href="/resume/">Resume</a></li>
        <li><a href="/about/">About</a></li>
      </ul>
    </nav>
  </header>

  <main>
	  <article class="hentry" itemscope itemtype="https://schema.org/Article">
  <h1 class="entry-title" itemprop="headline">Static Access to Request-Specific Data</h1>
  <p id="author">By <a href="http://codecube.net" title="More posts by Joel Martinez" rel="author" itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="name">Joel Martinez</span></a> on <time class="published" itemprop="datePublished" datetime="2009-11-03">11/03/2009</time>
</p>
  
  
  <div class="entry-content" itemprop="articleBody">
    I wrote a post over on the <a title="nGenSoft Blog" href="http://blog.ngensoft.net/">nGenSoft Blog</a> talking about how to gain <em><a href="http://blog.ngensoft.net/2009/11/02/static-access-to-request-specific-data/">Static Access to Request-Specific Data</a></em>:
<blockquote>As we have all come to learn in the last decade plus of web development, web applications are inherently stateless.  Unlike their native client cousins, every request must be treated as if it was done in isolation from any other user action.  This can tend to complicate application level concerns.  More often than not people just end up polluting their application by mixing code that is related to servicing the http request, with their business logic.<br /><br />We wanted a way to maintain application related plumbing such as database connections neatly maintained, without having to always worry about the stateless nature of http requests.  We noticed that ASP.NET has a really nice pattern that works really well in the HttpContext.Current property.  This is a static property that contains information about only the current request … at first I couldn’t figure out how this works because ASP.NET is by nature a multi-threaded environment.  How was it segregating the information, which is accessed statically, to each individual requests?</blockquote>
<hr /><em>Update: repost of original text can now be found below
</em><br /><br />As we have all come to learn in the last decade plus of web development, web applications are inherently stateless.  Unlike their native client cousins, every request must be treated as if it was done in isolation from any other user action.  This can tend to complicate application level concerns.  More often than not people just end up polluting their application by mixing code that is related to servicing the http request, with their business logic.<br /><br />We wanted a way to maintain application related plumbing such as database connections neatly maintained, without having to always worry about the stateless nature of http requests.  We noticed that ASP.NET has a really nice pattern that works really well in the HttpContext.Current property.  This is a static property that contains information about only the current request ... at first I couldn't figure out how this works because ASP.NET is by nature a multi-threaded environment.  How was it segregating the information, which is accessed statically, to each individual requests?<br /><br />After doing some research online, I finally figured out a great way to maintain request level state across different components (ie. http module --&gt; http handler --&gt; mvc action filter --&gt; etc.). I did a good bit of searching, but found it was succinctly put in a blog post by hanselman:<br /><br /><a href="http://www.hanselman.com/blog/ATaleOfTwoTechniquesTheThreadStaticAttributeAndSystemWebHttpContextCurrentItems.aspx" target="_blank">http://www.hanselman.com/blog/ATaleOfTwoTechniquesTheThreadStaticAttributeAndSystemWebHttpContextCurrentItems.aspx</a><br /><br />I started off by looking at (ie. Reflectoring) how the enigmatic HttpContext.Current works. Turns out there’s a lot of magic going on under the hood there with the web hosting framework and further .net remoting. In the end, looks like there are two simple ways to solve this problem:
<ul>
	<li>[ThreadStatic] attribute lets you have an instance of your static *per* thread.</li>
	<li>HttpContext.Current.Items, only usable in the context of <a href="http://asp.net/" target="_blank">asp.net</a> obviously, but correctly manages your scope for the lifetime of the request.</li>
</ul>
As hanselman puts it:
<blockquote>Today's lesson learned:the [<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemthreadstaticattributeclasstopic.asp" target="_blank">ThreadStatic</a>] attribute is only useful when YOU control the ThreadPool (and the lifecycle of the threads).</blockquote>
So it seems that in order to solve the problem we need to adapt our strategy.  If our app is running in a local client (ie. stateful), we can either use the threadstatic attribute, or nothing at all if we don't plan on doing complex multithreading.  However, if we are executing our application's code in an asp.net app, we need to use HttpContext.Current.Items.  Armed with this knowledge, we could have a small initialization step that lets you set up the strategy for how to manage session information. So in the app_start method of the global asax, we can do something like:
<pre>AppContext.SetEnvironment(new AppEnvironment());</pre>
Thus, in <a href="http://asp.net/" target="_blank">ASP.NET</a> you have an implementation that can know how to provide the proper scoping for that hosting environment. AppContext is defined as:
<pre>public interface IAppEnvironment
{
    public AppContext Current { get; set; }
}
public class AppContext
{
    // instance data
    public IDatabase Database { get; set; }<br /><br />    // static lifecycl
    private static IAppEnvironment environment;<br /><br />    public static void SetEnvironment(IAppEnvironment env) { environment = env; }<br /><br />    public static AppContext Current
    {
        get { return environment.Current; }
        set { environment.Current = value; }
    }
}</pre>
The instance data can be whatever you want … in the case of a data-driven app, it can maintain a request level database connection and whatever other information we need to refer to (which you can easily do by just saying “AppContext.Current.Database”). The static “Current” property that everyone would use simply defers to the environment implementation. Below are two implementations of the IAppEnvironment that you can use from <a href="http://asp.net/" target="_blank">ASP.NET</a> and a custom one  that you can use in a console app, or unit test.
<pre>public class WebEnvironment : IAppEnvironment
{
    public AppContext Current
    {
        get { return HttpContext.Current.Items["appcontext"] as AppContext; }
        set { HttpContext.Current.Items["appcontext"] = value; }
    }
}<br /><br />public class CustomEnvironment : IAppEnvironment
{
    [ThreadStatic]
    private static AppContext context;<br /><br />    public AppContext Current
    {
        get { return context; }
        set { context = value; }
    }
}</pre>
The CustomEnvironment implementation above just uses the simple thread static attribute since it’s assuming that you will be managing the hosting environment (threading and all) … where in the WebEnvironment, you can defer to the httpcontext stuff since that is handled for you.<br /><br />Techniques such as these let you focus on your application, while limiting the amount of time that you have to spend worrying complexities of adapting your application to run in a web application.
  </div>
</article>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Static Access to Request-Specific Data",
  "description": "I wrote a post over on the nGenSoft Blog talking about how to gain Static Access to Request-Specific Data:\nAs we have all come to learn in the last decade plus of web development, web applications ...",
  "author": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net/about/"
  },
  "publisher": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net"
  },
  "datePublished": "2009-11-03",
  "dateModified": "2009-11-03",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://codecube.net/2009/11/static-access-to-request-specific-data/"
  }
}
</script>

<p><strong>Latest post:</strong> <a href="/2025/7/team-series-death-by-status/"> Death By Status</a></p>


<p>See more in the <a href="/#archives">archives</a>
</p>

  </main>

  <footer>
    copyright 2013 - 2025 - <a rel="me" href="https://mastodon.social/@joelmartinez">me @ Mastodon</a> and <a rel="me" href="https://www.threads.net/@joeldm1971">Threads</a>
  </footer>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WV9DDDSFMW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WV9DDDSFMW');
</script>
</body>
</html>
