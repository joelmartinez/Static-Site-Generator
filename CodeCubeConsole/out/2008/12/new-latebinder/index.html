<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>New LateBinder</title>
  <meta name="author" content="Joel Martinez" />
  <meta name="nlweb:ai-access" content="allow" />
  <link rel="icon" type="image/svg+xml" href="/design/images/codecube-logo-web.svg" />
  <link rel="alternate" type="application/rss+xml" title="New LateBinder" href="//codecube.net/feed/" />
  <link rel="nlweb-manifest" href="/nlweb.json" />
	<link rel="stylesheet" type="text/css" href="/design/style2.css" />
      <meta name="title" content="New LateBinder" />
      <meta name="description" content="A long time ago, I posted a class called LateBinder to this site (the  previous blog software).&#xA0; I went on to use it rather prodigiously at work, and  it also turned out to be a boon to others who ..." />
      <link rel="canonical" href="http://codecube.net/2008/12/new-latebinder/" />
      <meta name="twitter:card" content="summary" />
      <meta name="twitter:site" content="@joelmartinez" />
      <meta name="twitter:creator" content="@joelmartinez" />
      <meta name="twitter:title" content="New LateBinder" />
      <meta name="twitter:description" content="A long time ago, I posted a class called LateBinder to this site (the  previous blog software).&#xA0; I went on to use it rather prodigiously at work, and  it also turned out to be a boon to others who ..." />
      <meta property="og:type" content="article" />
      <meta property="og:title" content="New LateBinder" />
      <meta property="og:description" content="A long time ago, I posted a class called LateBinder to this site (the  previous blog software).&#xA0; I went on to use it rather prodigiously at work, and  it also turned out to be a boon to others who ..." />
  
  <script src="/script/tone.js"></script>
</head>
<body>
  <header>
    <div class="branding">
      <a href="/" style="text-decoration: none; display: flex; align-items: center; gap: 1rem;">
        <img
          src="/design/images/codecube-logo-web.svg"
          alt="CodeCube Ventures logo"
          height="48"
          id="site-logo"
        />
        <div class="site-title">
          <span class="title-main">CODECUBE</span>
          <span class="title-sub">VENTURES</span>
        </div>
      </a>
    </div>
    <nav>
      <ul class="nav-list">
        <li><a href="/resume/">Resume</a></li>
        <li><a href="/about/">About</a></li>
      </ul>
    </nav>
  </header>

  <main>
	  <article class="hentry" itemscope itemtype="https://schema.org/Article">
  <h1 class="entry-title" itemprop="headline">New LateBinder</h1>
  <p id="author">By <a href="http://codecube.net" title="More posts by Joel Martinez" rel="author" itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="name">Joel Martinez</span></a> on <time class="published" itemprop="datePublished" datetime="2008-12-11">12/11/2008</time>
</p>
  <div class="entry-content" itemprop="articleBody">
    A long time ago, I posted a class called LateBinder to this site (the  previous blog software).  I went on to use it rather prodigiously at work, and  it also turned out to be a boon to others who visited this site (for example,  Victor of <a href="http://www.flatredball.com/">FlatRedBall</a> fame).   Unfortunately, it did have a few limitations; namely that it didn't support  getting/setting static fields and properties, and it also didn't work on the  xbox360 and zune because the System.Reflection.Emit namespace wasn't  available.<br /><br />He asked me the other day the feasibility of supporting the static  properties, and after a few days of hacking about, I've added that, and then  some :-)<br /><br />The version (below) not only supports static fields and properties, but it  also supports the xbox360 and zune platforms.  Be warned though, I had to fall  back on using simple reflection on the non-windows platforms ... so the perf  will obviously be slightly slower. <br /><br />I am fairly proud of how I was able to refactor the code to encapsulate the  cross-platform differences.  If you look at the LateBindFactory abstract class,  it uses a factory method to instantiate the platform-specific version.  This  way, I was able to keep the pre-processor directives to a minimum, using them  only where I needed ... and also keeping the same public API for both  platforms.<br /><br />Let me know if this is useful for you  :-)
<blockquote>#region Using Statements<br /><br />#if !XBOX360 &amp;&amp; !ZUNE
#define USE_EMIT
#endif<br /><br />using System;
using System.Collections.Generic;
using  System.Reflection;
#if USE_EMIT
using System.Reflection.Emit;
#endif<br /><br />#endregion<br /><br />namespace Scurvy
{
    /// &lt;summary&gt;
    /// Provides a simple  interface to late bind a class.
    /// &lt;/summary&gt;
    ///  &lt;remarks&gt;The first time you attempt to get or set a property, it will  dynamically generate the get and/or set
    /// methods and cache them  internally.  Subsequent gets uses the dynamic methods without having to query  the type's
    /// meta data.&lt;/remarks&gt;
    public sealed class  LateBinder&lt;T&gt;
    {
        #region Fields<br /><br />        private static LateBindFactory factory =  LateBindFactory.Create();
        private BindingFlags propertyFlags =  BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static;
         private Type mType;
        private Dictionary&lt;string, GetHandler&gt;  mPropertyGet;
        private Dictionary&lt;string, SetHandler&gt;  mPropertySet;<br /><br />        private Dictionary&lt;Type, List&lt;string&gt;&gt; mFields;<br /><br />        private T mTarget = default(T);<br /><br />        private static LateBinder&lt;T&gt; _instance;<br /><br />        #endregion<br /><br />        #region Properties<br /><br />        public static LateBinder&lt;T&gt; Instance
         {
            get { return _instance; }
        }<br /><br />        /// &lt;summary&gt;
        /// The instance that this binder  operates on by default
        /// &lt;/summary&gt;
        ///  &lt;remarks&gt;This can be overridden by the caller explicitly passing a target  to the indexer&lt;/remarks&gt;
        public T Target
         {
            get { return mTarget; }
            set { mTarget = value;  }
        }<br /><br />        /// &lt;summary&gt;
        /// Gets or Sets the supplied property  on the contained &lt;seealso cref="Instance"/&gt;
        ///  &lt;/summary&gt;
        /// &lt;exception  cref="InvalidOperationException"&gt;Throws if the contained Instance is  null.&lt;/exception&gt;
        public object this[string  propertyName]
        {
            get
             {
                //ValidateInstance();
                return  this[mTarget, propertyName];
            }
            set
             {
                //ValidateInstance();
                this[mTarget,  propertyName] = value;
            }
        }<br /><br />        /// &lt;summary&gt;
        /// Gets or Sets the supplied property  on the supplied target
        /// &lt;/summary&gt;
        public object  this[T target, string propertyName]
        {
             get
            {
                ValidateGetter(ref  propertyName);
                return  mPropertyGet[propertyName](target);
            }
             set
            {
                ValidateSetter(ref  propertyName);
                mPropertySet[propertyName](target,  value);
            }
        }<br /><br />        #endregion<br /><br />        #region Methods<br /><br />        #region Constructors<br /><br />        static LateBinder()
        {
            _instance = new  LateBinder&lt;T&gt;();
        }<br /><br />        public LateBinder(T instance)
            : this()
         {
            mTarget = instance;
        }<br /><br />        public LateBinder()
        {
            mType =  typeof(T);
            mPropertyGet = new Dictionary&lt;string,  GetHandler&gt;();
            mPropertySet = new Dictionary&lt;string,  SetHandler&gt;();<br /><br />            mFields = new Dictionary&lt;Type,  List&lt;string&gt;&gt;();
        }
        #endregion<br /><br />        #endregion<br /><br />        #region Public Accessors<br /><br />        /// &lt;summary&gt;
        /// Sets the supplied property on the  supplied target
        /// &lt;/summary&gt;
        /// &lt;typeparam  name="K"&gt;the type of the value&lt;/typeparam&gt;
        public void  SetProperty&lt;K&gt;(T target, string propertyName, K value)
        {
#if  !USE_EMIT<br /><br />            // find out if this is a property or field
            Type  type = typeof(T);<br /><br />            PropertyInfo propertyInfo = type.GetProperty(propertyName);<br /><br />            if (propertyInfo != null)
            {
                 propertyInfo.SetValue(target, value, null);
            }<br /><br />            else
            {
                FieldInfo fieldInfo =  type.GetField(propertyName);<br /><br />                if (fieldInfo != null)
                 {
                    fieldInfo.SetValue(target, value);
                 }
                else
                {
                    throw new  ArgumentException("Cannot find property or field with the name " +  propertyName);
                }<br /><br />            }<br /><br />#else
            ValidateSetter(ref propertyName);<br /><br />            if (mPropertySet.ContainsKey(propertyName))
             {
                mPropertySet[propertyName](target, value);
             }
            else
            {
                // This is probably  not a property so see if it is a field.<br /><br />                FieldInfo fieldInfo = mType.GetField(propertyName);<br /><br />                if (fieldInfo == null)
                 {
                    string errorMessage =
                         "LateBinder could not find a field or property by the name of " + propertyName  +
                        "Check the name of the property to verify if it is  correct.";
                    throw new  System.MemberAccessException(errorMessage);
                 }
                else
                {
                    object[]  args = { value };
                    mType.InvokeMember(propertyName,  BindingFlags.SetField, null, target, args);
                }
             }
#endif
        }<br /><br />        public object GetField(T target, ref string propertyName)
         {
            Binder binder = null;
            object[] args = null;<br /><br />            return mType.InvokeMember(
                propertyName,
               BindingFlags.GetField,
                binder,
               target,
               args
                );
        }<br /><br />        /// &lt;summary&gt;
        /// Gets  the supplied property on the  supplied target
        /// &lt;/summary&gt;
        /// &lt;typeparam  name="K"&gt;The type of the property being returned&lt;/typeparam&gt;
         public K GetProperty&lt;K&gt;(T target, ref string propertyName)
         {
            ValidateGetter(ref propertyName);
            return  (K)mPropertyGet[propertyName](target);
        }<br /><br />        public object GetProperty(T target, ref string  propertyName)
        {
            ValidateGetter(ref  propertyName);
            return  mPropertyGet[propertyName](target);
        }<br /><br />        #endregion<br /><br />        #region Private Helpers<br /><br />        private void ValidateInstance()
        {
            if  (mTarget == null)
            {
                throw new  InvalidOperationException("Instance property must not be null");
             }
        }<br /><br />        private void ValidateSetter(ref string propertyName)
         {
            if (!mPropertySet.ContainsKey(propertyName))
             {
                PropertyInfo propertyInfo = mType.GetProperty(propertyName,  this.propertyFlags);<br /><br />                if (propertyInfo != null)
                 {
                    mPropertySet.Add(propertyName,  factory.CreateSetHandler(mType, propertyInfo));
                 }
            }
        }<br /><br />        private void ValidateGetter(ref string propertyName)
         {
            if (!mPropertyGet.ContainsKey(propertyName))
             {
                mPropertyGet.Add(propertyName,  factory.CreateGetHandler(mType,  mType.GetProperty(propertyName)));
            }
        }<br /><br />        #endregion<br /><br />        #region Contained Classes<br /><br />        internal delegate object GetHandler(object source);
         internal delegate void SetHandler(object source, object value);
         internal delegate object InstantiateObjectHandler();<br /><br />        internal abstract class LateBindFactory
        {
             public LateBindFactory()
            {
            }<br /><br />            public static LateBindFactory Create()
            {
#if  USE_EMIT
                return new  DynamicMethodFactory();
#else
                return new  ReflectionFactory();
#endif
            }<br /><br />            public abstract InstantiateObjectHandler  CreateInstantiateObjectHandler(Type type);
            public abstract  GetHandler CreateGetHandler(Type type, PropertyInfo  propertyInfo);
            public abstract GetHandler CreateGetHandler(Type  type, FieldInfo fieldInfo);
            public abstract SetHandler  CreateSetHandler(Type type, PropertyInfo propertyInfo);
            public  abstract SetHandler CreateSetHandler(Type type, FieldInfo fieldInfo);
         }<br /><br />#if USE_EMIT
        internal sealed class DynamicMethodFactory :  LateBindFactory
        {
            public  DynamicMethodFactory()
            {
            }<br /><br />            #region Public Methods<br /><br />            public override InstantiateObjectHandler  CreateInstantiateObjectHandler(Type type)
            {
                 ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public |  BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[0],  null);
                if (constructorInfo == null)
                 {
                    throw new ApplicationException(string.Format("The type  {0} must declare an empty constructor (the constructor may be private, internal,  protected, protected internal, or public).", type));
                }<br /><br />                DynamicMethod dynamicMethod = new  DynamicMethod("InstantiateObject", MethodAttributes.Static |  MethodAttributes.Public, CallingConventions.Standard, typeof(object), null,  type, true);
                ILGenerator generator =  dynamicMethod.GetILGenerator();
                 generator.Emit(OpCodes.Newobj, constructorInfo);
                 generator.Emit(OpCodes.Ret);
                return  (InstantiateObjectHandler)dynamicMethod.CreateDelegate(typeof(InstantiateObjectHandler));
             }<br /><br />            public override GetHandler CreateGetHandler(Type type,  PropertyInfo propertyInfo)
            {
                MethodInfo  getMethodInfo = propertyInfo.GetGetMethod(true);<br /><br />                DynamicMethod dynamicGet =  CreateGetDynamicMethod(type);
                ILGenerator getGenerator =  dynamicGet.GetILGenerator();<br /><br />                if (!getMethodInfo.IsStatic)
                 {
                    getGenerator.Emit(OpCodes.Ldarg_0);
                 }
                getGenerator.Emit(OpCodes.Call,  getMethodInfo);
                BoxIfNeeded(getMethodInfo.ReturnType,  getGenerator);
                getGenerator.Emit(OpCodes.Ret);<br /><br />                return  (GetHandler)dynamicGet.CreateDelegate(typeof(GetHandler));
            }<br /><br />            public override GetHandler CreateGetHandler(Type type, FieldInfo  fieldInfo)
            {<br /><br />                DynamicMethod dynamicGet =  CreateGetDynamicMethod(type);
                ILGenerator getGenerator =  dynamicGet.GetILGenerator();<br /><br />                if (!fieldInfo.IsStatic)
                 {
                    getGenerator.Emit(OpCodes.Ldarg_0);
                 }
                getGenerator.Emit(OpCodes.Ldfld,  fieldInfo);
                BoxIfNeeded(fieldInfo.FieldType,  getGenerator);
                getGenerator.Emit(OpCodes.Ret);<br /><br />                return  (GetHandler)dynamicGet.CreateDelegate(typeof(GetHandler));
            }<br /><br />            public override SetHandler CreateSetHandler(Type type,  PropertyInfo propertyInfo)
            {
                MethodInfo  setMethodInfo = propertyInfo.GetSetMethod(true);<br /><br />                DynamicMethod dynamicSet =  CreateSetDynamicMethod(type);
                ILGenerator setGenerator =  dynamicSet.GetILGenerator();<br /><br />                if (!setMethodInfo.IsStatic)
                 {
                    setGenerator.Emit(OpCodes.Ldarg_0);
                 }
                setGenerator.Emit(OpCodes.Ldarg_1);
                 UnboxIfNeeded(setMethodInfo.GetParameters()[0].ParameterType,  setGenerator);
                setGenerator.Emit(OpCodes.Call,  setMethodInfo);
                setGenerator.Emit(OpCodes.Ret);<br /><br />                return  (SetHandler)dynamicSet.CreateDelegate(typeof(SetHandler));
            }<br /><br />            public override SetHandler CreateSetHandler(Type type, FieldInfo  fieldInfo)
            {
                DynamicMethod dynamicSet =  CreateSetDynamicMethod(type);
                ILGenerator setGenerator =  dynamicSet.GetILGenerator();<br /><br />                if (!fieldInfo.IsStatic)
                 {
                    setGenerator.Emit(OpCodes.Ldarg_0);
                 }
                setGenerator.Emit(OpCodes.Ldarg_1);
                 UnboxIfNeeded(fieldInfo.FieldType, setGenerator);<br /><br />                if (!fieldInfo.IsStatic)
                 {
                    setGenerator.Emit(OpCodes.Stfld,  fieldInfo);
                }
                else
                 {
                    setGenerator.Emit(OpCodes.Stsfld,  fieldInfo);
                }<br /><br />                setGenerator.Emit(OpCodes.Ret);<br /><br />                return  (SetHandler)dynamicSet.CreateDelegate(typeof(SetHandler));
            }<br /><br />            #endregion<br /><br />            #region Private Methods<br /><br />            private static DynamicMethod CreateGetDynamicMethod(Type  type)
            {
                return new DynamicMethod("DynamicGet",  typeof(object), new Type[] { typeof(object) }, type, true);
            }<br /><br />            // CreateSetDynamicMethod
            private static  DynamicMethod CreateSetDynamicMethod(Type type)
             {
                return new DynamicMethod("DynamicSet", typeof(void), new  Type[] { typeof(object), typeof(object) }, type, true);
            }<br /><br />            // BoxIfNeeded
            private static void  BoxIfNeeded(Type type, ILGenerator generator)
             {
                if (type.IsValueType)
                 {
                    generator.Emit(OpCodes.Box, type);
                 }
            }<br /><br />            // UnboxIfNeeded
            private static void  UnboxIfNeeded(Type type, ILGenerator generator)
             {
                if (type.IsValueType)
                 {
                    generator.Emit(OpCodes.Unbox_Any,  type);
                }
            }<br /><br />            #endregion
        }
#endif<br /><br />#if !USE_EMIT
        internal sealed class ReflectionFactory :  LateBindFactory
        {
            public  ReflectionFactory()
            {
            }<br /><br />            public override InstantiateObjectHandler  CreateInstantiateObjectHandler(Type type)
            {
                 return delegate()
                {
                    return  Activator.CreateInstance(type);
                };
            }<br /><br />            public override GetHandler CreateGetHandler(Type type,  PropertyInfo propertyInfo)
            {
                MethodInfo method  = propertyInfo.GetGetMethod(true);<br /><br />                return delegate(object source)
                 {
                    return method.Invoke(method.IsStatic ? null : source,  null);
                };
            }<br /><br />            public override GetHandler CreateGetHandler(Type type, FieldInfo  fieldInfo)
            {
                return delegate(object  source)
                {
                    return  fieldInfo.GetValue(fieldInfo.IsStatic ? null : source);
                 };
            }<br /><br />            public override SetHandler CreateSetHandler(Type type,  PropertyInfo propertyInfo)
            {
                MethodInfo method  = propertyInfo.GetSetMethod();<br /><br />                return delegate(object source, object  value)
                {
                    method.Invoke(method.IsStatic  ? null : source, new object[] { value });
                };
            }<br /><br />            public override SetHandler CreateSetHandler(Type type, FieldInfo  fieldInfo)
            {
                return delegate(object source,  object value)
                {
                     fieldInfo.SetValue(fieldInfo.IsStatic ? null : source,  value);
                };
            }
        }
#endif
         #endregion
    }
}</blockquote>
  </div>
</article>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "New LateBinder",
  "description": "A long time ago, I posted a class called LateBinder to this site (the  previous blog software).&#xA0; I went on to use it rather prodigiously at work, and  it also turned out to be a boon to others who ...",
  "author": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net/about/"
  },
  "publisher": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net"
  },
  "datePublished": "2008-12-11",
  "dateModified": "2008-12-11",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://codecube.net/2008/12/new-latebinder/"
  }
}
</script>

<p><strong>Latest post:</strong> <a href="/2025/7/team-series-size/"> When Your Team Gets Bigger - How Teams Grow</a></p>

<p>See more in the <a href="/#archives">archives</a>
</p>

  </main>

  <footer>
    copyright 2013 - 2025 - <a rel="me" href="https://mastodon.social/@joelmartinez">me @ Mastodon</a> and <a rel="me" href="https://www.threads.net/@joeldm1971">Threads</a>
  </footer>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WV9DDDSFMW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WV9DDDSFMW');
</script>
</body>
</html>
