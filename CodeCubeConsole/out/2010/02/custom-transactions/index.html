<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Custom Transactions</title>
  <meta name="author" content="Joel Martinez" />
  <meta name="nlweb:ai-access" content="allow" />
  <link rel="icon" type="image/svg+xml" href="/design/images/codecube-logo-web.svg" />
  <link rel="alternate" type="application/rss+xml" title="Custom Transactions" href="//codecube.net/feed/" />
  <link rel="nlweb-manifest" href="/nlweb.json" />
	<link rel="stylesheet" type="text/css" href="/design/style2.css" />
      <meta name="title" content="Custom Transactions" />
      <meta name="description" content="If you haven&#x27;t used TransactionScope from the System.Transactions namespace, you don&#x27;t know what you&#x27;re missing.&#xA0; This system, introduced with .NET 2.0 provides a flexible mechanism for allowing yo..." />
      <link rel="canonical" href="http://codecube.net/2010/02/custom-transactions/" />
      <meta name="twitter:card" content="summary" />
      <meta name="twitter:site" content="@joelmartinez" />
      <meta name="twitter:creator" content="@joelmartinez" />
      <meta name="twitter:title" content="Custom Transactions" />
      <meta name="twitter:description" content="If you haven&#x27;t used TransactionScope from the System.Transactions namespace, you don&#x27;t know what you&#x27;re missing.&#xA0; This system, introduced with .NET 2.0 provides a flexible mechanism for allowing yo..." />
      <meta property="og:type" content="article" />
      <meta property="og:title" content="Custom Transactions" />
      <meta property="og:description" content="If you haven&#x27;t used TransactionScope from the System.Transactions namespace, you don&#x27;t know what you&#x27;re missing.&#xA0; This system, introduced with .NET 2.0 provides a flexible mechanism for allowing yo..." />
  
  <script src="/script/tone.js"></script>
</head>
<body>
  <header>
    <div class="branding">
      <a href="/" style="text-decoration: none; display: flex; align-items: center; gap: 1rem;">
        <img
          src="/design/images/codecube-logo-web.svg"
          alt="CodeCube Ventures logo"
          height="48"
          id="site-logo"
        />
        <div class="site-title">
          <span class="title-main">CODECUBE</span>
          <span class="title-sub">VENTURES</span>
        </div>
      </a>
    </div>
    <nav>
      <ul class="nav-list">
        <li><a href="/resume/">Resume</a></li>
        <li><a href="/about/">About</a></li>
      </ul>
    </nav>
  </header>

  <main>
	  <article class="hentry" itemscope itemtype="https://schema.org/Article">
  <h1 class="entry-title" itemprop="headline">Custom Transactions</h1>
  <p id="author">By <a href="http://codecube.net" title="More posts by Joel Martinez" rel="author" itemprop="author" itemscope itemtype="https://schema.org/Person"><span itemprop="name">Joel Martinez</span></a> on <time class="published" itemprop="datePublished" datetime="2010-02-08">02/08/2010</time>
</p>
  <div class="entry-content" itemprop="articleBody">
    If you haven't used TransactionScope from the System.Transactions namespace, you don't know what you're missing.  This system, introduced with .NET 2.0 provides a flexible mechanism for allowing your code to take part in transactions.  Many of the built-in subsystems such as ADO.NET automatically enlist in these transactions, but the real power comes from the fact that you can allow your own custom code to also take part in ambient transactions.<br /><br />Recently at work, I wanted to perform a transaction across several unrelated modules with a custom resource. Of course TransactionScope was the first solution brought up. Unfortunately, after some analysis, I realized that this wasn't going to work for us; We have existing database code in those modules that have different conditions in which the transaction would be rolled back.<br /><br />We needed a way to have multiple transaction scopes, each with different conditions of success or failure. I started thinking about how to accomplish this, and decided to write my own implementation which mimics the TransactionScope, but lets me control things a bit closer.  So I came up with a class which can be used like this:
<blockquote>
<pre>using (Txn scope = Txn.New&lt;MyScope&gt;())
{
    // ... do work<br /><br />    scope.Commit();
}</pre>
</blockquote>
Notice that the usage pattern is nearly identical to the TransactionScope API ... put the scope in a using statement, and call .Commit if the work was completed.  In the example above, the MyScope class is defined quite simply as:
<blockquote><pre>public class MyScope : Txn
{
    protected override void OnStart()
    {
        Console.WriteLine(&quot;\tstarting&quot;);
    }<br /><br />    protected override void OnCommit()
    {
        Console.WriteLine(&quot;\tcommitting&quot;);
    }<br /><br />    protected override void OnRollback()
    {
        Console.WriteLine(&quot;\trolling back&quot;);
    }
}</pre></blockquote>
All you have to do is inherit from the Txn class, and implement three methods:  OnStart, which occurs when the transaction is first beginning; OnCommit, which is invoked only when the top-most scope exits and all sub transactions were committed successfully; And OnRollback, which as you might imagine is only called if the transaction (or a subtransaction) was not committed successfully.<br /><br />One difference between this API and the regular TransactionScope is that only one instance of "MyScope" will be created when the top-most transaction is first created.  As I've alluded to, you can nest transactions just as you can with TransactionScope.  And each scope must be committed if the entire transaction is to be completed.<br /><br />The Txn class can be found below:
<blockquote><pre>public abstract class Txn : IDisposable
{
    private Queue&lt;bool&gt; committed = new Queue&lt;bool&gt;();<br /><br />    public Txn()
    {
    }<br /><br />    [ThreadStatic]
    public static bool committable = true;<br /><br />    [ThreadStatic]
    public static int depth = 0;<br /><br />    [ThreadStatic]
    public static Txn current;<br /><br />    protected abstract void OnStart();
    protected abstract void OnCommit();
    protected abstract void OnRollback();<br /><br />    public void Commit()
    {
        this.committed.Enqueue(true);
    }<br /><br />    void IDisposable.Dispose()
    {
        if (committed.Count == 0 || !committed.Dequeue())
        {
            committable = false;
        }<br /><br />        depth--;
        if (depth == 0)
        {
            if (committable)
            {
                this.OnCommit();
            }
            else
            {
                this.OnRollback();
            }<br /><br />            current = null;
        }
    }<br /><br />
    public static T New&lt;T&gt;() where T : Txn, new()
    {
        depth++;<br /><br />        if (current == null)
        {
            current = new T();
        }<br /><br />        if (depth == 1)
        {
            // first transaction, assume committable
            committable = true;
            current.OnStart();
        }<br /><br />        return current as T;
    }<br /><br />    #region IDisposable Members<br /><br />    #endregion
}</pre></blockquote>
There is one caveat to mention. My requirement was to run this code in a windows service. The entire scope of the transaction would be single threaded, but there would be multiple ongoing transactions at once. To support this scenario, notice that some of the internal state of the Txn class uses the [ThreadStatic] attribute. This means that the API can be used from multiple threads at once and each thread would have its own state.  <br /><br />Of course, this might be a problem if you want to use this in an ASP.NET project. I've <a href="http://blog.ngensoft.net/2009/11/02/static-access-to-request-specific-data/">written about this issue</a> before. There is probably a way to make this work using the techniques I outlined in that article, but I haven't given it a lot of thought (because I didn't need to).  But I thought I'd share the work I did in case it is useful for anyone else.  
  </div>
</article>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Custom Transactions",
  "description": "If you haven&#x27;t used TransactionScope from the System.Transactions namespace, you don&#x27;t know what you&#x27;re missing.&#xA0; This system, introduced with .NET 2.0 provides a flexible mechanism for allowing yo...",
  "author": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net/about/"
  },
  "publisher": {
    "@type": "Person",
    "name": "Joel Martinez",
    "url": "https://codecube.net"
  },
  "datePublished": "2010-02-08",
  "dateModified": "2010-02-08",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://codecube.net/2010/02/custom-transactions/"
  }
}
</script>

<p><strong>Latest post:</strong> <a href="/2025/7/team-series-size/"> When Your Team Gets Bigger - How Teams Grow</a></p>

<p>See more in the <a href="/#archives">archives</a>
</p>

  </main>

  <footer>
    copyright 2013 - 2025 - <a rel="me" href="https://mastodon.social/@joelmartinez">me @ Mastodon</a> and <a rel="me" href="https://www.threads.net/@joeldm1971">Threads</a>
  </footer>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WV9DDDSFMW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WV9DDDSFMW');
</script>
</body>
</html>
